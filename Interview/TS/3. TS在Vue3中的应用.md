
**使用方式**：
- `vite`构建项目时选择语言为`TypeScript`
- `script` 加上 `lang="ts"`
```xml
<script setup lang="ts"></script>
```

## 一、defineProps

### 1.基本使用
```ts
// 原Vue3的JS写法
defineProps({
	money: {
		type: Number,
		required: true
	},
	car: {
		type: String,
		required: false,
		default: '宝马车'
	}
})

// 泛型函数写法 👏🏼
defineProps<{
	money: number
	car?: string //不加可选属性`?`，则限制必传（默认必传，无需`required`）
}>()

// 泛型接口写法 👏🏼
interface Props {
	money: number
	car?: string
}
defineProps<Props>()
```

### 2.设置默认值
语法：`withDefaults(props定义, 默认值对象)`

```ts
// 写法一：不声明类型直接写
withDefaults(defineProps<{
	money: number
	car?: string // 只有可选属性可以设置默认值
}>(),{
  car: '宝马车'
})

// 写法二：使用接口声明对象类型
interface Props {
	money: number
	car?: string // 只有可选属性可以设置默认值
}
withDefaults(defineProps<Props>(),{
	car: '宝马车' 
})
```

#### 响应式 props 解构
**作用**：弥补`defineProps`的两个缺点
1. 和 `.value` 类似，为了保持响应性，你始终需要以 `props.x` 的方式访问这些 prop。这意味着你不能够解构 `defineProps` 的返回值，因为得到的变量将失去响应式。
2. 当使用**基于类型的 props 的声明**（即：TS的接口声明）时，无法很方便地声明这些 prop 的默认值。即使有 `withDefaults()` 这个 API，使用起来仍然很笨拙。

**语法**：`defineProps` 与解构一起使用
```ts
interface Props {
	money: number
	car?: string
}
const { money, car = "宝马车" } = defineProps<Props>();
```

**显式启用**:
```js
// vite.config.js
export default {
  plugins: [
    vue({
      reactivityTransform: true
    })
  ]
}
```

## 二、defineEmits

### 基本使用
```ts
// 原Vue3的JS写法
const emit = defineEmits(['changeMoney', 'changeCar'])

// 泛型函数+函数签名写法 👏🏼
const emit = defineEmits<{ 
	(name: 'changeMoney', value: number): void 
	(name: 'changeCar', value: string): void 
}>()

// 泛型接口+函数签名写法 👏🏼
interface Emits { 
	(name: 'changeMoney', value: number): void 
	(name: 'changeCar', value: string): void 
} 
const emit = defineEmits<Emits>()
```

####  函数的调用签名
目的：更加精确地限制函数的参数，实现统一声明但一一对应的效果
```ts
// 普通函数的写法
type MyFn = (name: "changeNum" | "changeStr", value: number | string ) => void
const fn: MyFn = (name, value) => {};
// 均不报错
fn("changeNum", "1");
fn("changeMsg", 1);
fn("changeNum", "1");
fn("changeMsg", 1);

// 函数的调用签名写法
// ⭐️函数类型表达式语法不允许声明属性，所以要使用对象类型（函数也是对象）
interface MyFn { 
	(name: "changeNum", value: number): void; 
	(name: "changeStr", value: string): void; 
}
const fn: MyFn = (name, value) => {};
fn("changeNum", "1"); // ❌
fn("changeMsg", 1); // ❌
fn("changeNum", "1"); // ✅ 
fn("changeMsg", 1); // ✅
```

## 三、响应式数据

### 1.ref()
```ts
// 简单数据, 直接使用类型推导
const money = ref(100)
const car = ref('五菱')

// 复杂数据, 使用泛型函数，传入类型别名作为泛型参数
// 作用：通过限制函数ref()的参数类型，来限制其类型推断，其返回值又会限制变量的类型
type HistoryType = {count: number, time: string}[]
const list = ref<HistoryType>([])
list.value.push({
    count: 100,
    time: '2023-01-01'
})
```

### 2.reactive()
```ts
// 官方建议reactive()直接对变量使用类型别名, 不用泛型
type BookType = {
  name: string
  author: string
}
const book: BookType = reactive({
  name: 'js入门',
  author: '张三',
})
```

## 四、计算属性

